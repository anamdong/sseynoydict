<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>架空体系字音</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif; margin:0; }
    .wrap { max-width: 1080px; margin: 0 auto; padding: 18px; }
    h1 { font-size: 18px; margin: 0 0 12px; }
    .card { border: 1px solid rgba(127,127,127,.35); border-radius: 12px; padding: 14px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    input[type="text"], input[type="url"]{
      flex:1; min-width: 260px; padding: 10px 12px; border-radius: 10px;
      border: 1px solid rgba(127,127,127,.45); font-size: 16px;
    }
    button{
      touch-action: manipulation;
      -webkit-tap-highlight-color: rgba(0,0,0,0);

      padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(127,127,127,.45);
      background: transparent; cursor:pointer; font-size: 16px;
    }
    button:hover { filter: brightness(1.06); }
    .hint { font-size: 12px; opacity: .75; margin-top: 8px; line-height: 1.55; }
    .status{
      margin-top:10px; font-size:12px; opacity:.92; padding:10px 12px; border-radius:10px;
      border: 1px solid rgba(127,127,127,.35);
    }
    .ok{ border-left:4px solid rgba(40,160,80,.9); background: rgba(40,160,80,.08); }
    .warn{ border-left:4px solid rgba(200,140,0,.9); background: rgba(200,140,0,.08); }
    .bad{ border-left:4px solid rgba(200,80,80,.9); background: rgba(200,80,80,.08); }
    .out{ margin-top:14px; }
    .charBlock{ border-top:1px dashed rgba(127,127,127,.35); padding-top:12px; margin-top:12px; }
    .charTitle{ display:flex; align-items:baseline; gap:10px; }
    .han{ font-size:28px; font-weight:800; }
    .meta{ font-size:12px; opacity:.75; }
    .entry{ padding:10px 12px; border:1px solid rgba(127,127,127,.35); border-radius:12px; margin-top:10px; }
    .entryHeader{ display:flex; gap:10px; flex-wrap:wrap; align-items:baseline; }
    .tag{ font-size:12px; padding:2px 8px; border:1px solid rgba(127,127,127,.35); border-radius:999px; opacity:.85; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .reading{ font-size:18px; font-weight:800; }
    .small{ font-size:12px; opacity:.78; margin-top:6px; line-height:1.55; }
    details{ margin-top:10px; }
    summary{ cursor:pointer; }
    .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    @media (max-width: 760px){ .grid2{ grid-template-columns: 1fr; } }
    textarea{
      width:100%; min-height:140px; border-radius:10px; border:1px solid rgba(127,127,127,.35);
      padding:10px 12px; font-size:12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }
  </style>
</head>
<body>
<div class="wrap">
  <h1>架空体系字音</h1>

  <div class="card">
    <div class="grid2">
      <div>
        <div class="row">
          <input id="url" type="url"
            value="./Kuankhiunn0704.txt"
            placeholder="Kuankhiunn0704.txt のURL（blobでもOK）" />
          <button id="loadUrlBtn">自動取得して読み込み</button>
        </div>
        <div class="hint">
          ・blob URLでもOK（アプリ内でraw URLに自動変換して取得します）。<br>
          ・取得が失敗する場合は、GitHub raw がブロックされている環境か、CORS制限の可能性があります（Pages/CDN推奨）。
        </div>
      </div>

      <div>
        <div class="row">
          <input id="q" type="text" placeholder="漢字を入力（複数OK）例：東同中蟲…" autocomplete="off" />
          <button id="searchBtn">検索</button>
          <button id="demoBtn">デモ</button>
        </div>
        <div class="hint">
          ・同一字に複数音があればリスト表示。<br>
          ・読み込み時に「韻名一覧」「未対応韻キー」を自動抽出します。
        </div>
      </div>
    </div>

    <div id="status" class="status warn">未読み込み：上のURLから読み込んでください。</div>

    <details>
      <summary>抽出結果（韻名一覧 / 未対応韻キー）</summary>
      <div class="small">
        <div class="mono" style="margin:8px 0 4px">韻名（rimeName）一覧</div>
        <textarea id="rimeNames" readonly></textarea>
        <div class="mono" style="margin:10px 0 4px">未対応の韻キー（RIME_ROMANに無い）</div>
        <textarea id="missingKeys" readonly></textarea>
      </div>
    </details>

    <div id="out" class="out"></div>
  </div>
</div>

<script>
let INDEX = new Map();
let RIME_ROMAN = {};

function setStatus(msg, kind="warn"){
  const el = document.getElementById("status");
  el.className = `status ${kind}`;
  el.textContent = msg;
}
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
}
function normalizeTextUrl(url){
  const m = url.match(/^https:\/\/github\.com\/([^/]+)\/([^/]+)\/blob\/([^/]+)\/(.+)$/);
  if (m){
    const [, user, repo, branch, path] = m;
    return `https://raw.githubusercontent.com/${user}/${repo}/${branch}/${path}`;
  }
  return url;
}

function stripBracketNotes(s){
  return (s||"")
    .replace(/\[[^\]]*\]/g, "")
    .replace(/\{[^}]*\}/g, "")
    .replace(/\([^)]*\)/g, "")
    .replace(/\s+/g, "");
}
function isCjkIdeograph(ch){
  const cp = ch.codePointAt(0);
  return (cp >= 0x3400 && cp <= 0x9FFF) || (cp >= 0x20000 && cp <= 0x2EBEF);
}
function splitIdeographs(s){
  const cleaned = stripBracketNotes(s);
  return Array.from(cleaned).filter(isCjkIdeograph);
}
function parseLine(line){
  if (!line || !line.includes("|")) return null;
  const parts = line.split("|").map(s => (s ?? "").trim());
  for (let i=0;i<parts.length;i++){
    const tok = parts[i];
    if (tok === "開" || tok === "合"){
      const initial = parts[i-1];
      const deng = parts[i+1];
      const rime = parts[i+2];
      const tone = parts[i+3];
      if (["一","二","三","四"].includes(deng) && ["平","上","去","入"].includes(tone) && initial){
        return { fanqie: parts[2]||"", charsRaw: parts[3]||"", initialMu: initial, kaihe: tok, deng, rimeName: rime, tone };
      }
    }
  }
  return null;
}

const INITIAL_ROMAN = {
  "幫":"b","滂":"p","並":"b","明":"m",
  "非":"f","敷":"f","奉":"f","微":"w",
  "端":"d","透":"t","定":"d","泥":"n",
  "知":"zh","徹":"ch","澄":"zh","娘":"nh",
  "精":"z","清":"c","從":"z","心":"s","邪":"x",
  "照":"zh","穿":"ch","牀":"s",
  "莊":"zh","初":"ch","崇":"s",
  "章":"zh","昌":"ch","常":"s",
  "審":"sh","禅":"sh",
  "生":"sh","俟":"sh",
  "書":"sh","船":"sh",
  "見":"g","溪":"k","群":"g","疑":"",
  "影":"'", "曉":"h","匣":"h","云":"",
  "以":"y","喩":"y",
  "來":"l","日":"r",
};
const VOICED_MU = new Set(["並","奉","定","澄","従","邪","牀","禅","群","匣"]);

const MASTER_RIME_ROMAN = {
  "東一":"ung","屋一":"uk","東三":"iung","屋三":"iuk",
  "冬一":"ong","沃":"ok","鍾三":"iong","燭":"iok",
  "江二":"ang","覺":"ak",
  "唐一":"ang","鐸":"ak","唐一合":"wang","鐸合":"wak",
  "陽三":"iang","藥":"iak","陽三合":"yang","藥合":"yak",
  "庚二":"aang","陌二":"aak","庚二合":"waang","陌二合":"waak","庚三":"iaang","陌三":"iaak","庚三合":"uaang","陌三合":"uaak",
  "耕二":"ang","麥":"ak","耕二合":"wang","麥合":"wak",
  "清三":"ing","昔":"ik","清三合":"ing","昔合":"ik",
  "青四":"eng","錫":"ek","青四合":"yeng","錫合":"yek",
  "登一":"ung","德":"uk","登一合":"wung","德合":"wuk",
  "蒸三":"ing","職":"ik","蒸三合":"wing","職合":"ik",
  "眞A三":"in","質A":"it",
  "眞B三":"in","質B":"it",
  "眞B三合":"uin","質B合":"uit",
  "臻三":"ien","櫛":"iet",
  "諄三合":"un","術":"ut",
  "痕一":"on",
  "魂一合":"won","沒":"wot",
  "欣三":"un","迄":"ut",
  "文三合":"un","物":"ut",
  "寒一開":"an","曷":"at",
  "桓一合":"wan","末":"wat",
  "元三":"ian","月":"iat","元三合":"uan","月合":"uat",
  "刪二":"an","黠":"at","刪二合":"wan","黠合":"wat",
  "山二":"aan","鎋":"aat","山二合":"waan","鎋合":"waat",
  "仙A三":"ien","薛A":"iet","仙A三合":"uen","薛A合":"uet",
  "仙B三":"ien","薛B":"iet","仙B三合":"uen","薛B合":"uet",
  "先四":"in","屑":"it","先四合":"uin","屑合":"uit",
  "侵A三":"im","緝A":"ip",
  "侵B三":"im","緝B":"ip",
  "談一":"am","盍":"ap",
  "嚴三":"iem","業":"iep",
  "凡三合":"yom","乏":"yop",
  "銜二":"aam","狎":"aap",
  "咸二":"em","洽":"ep",
  "鹽A三":"im","葉A":"ip",
  "鹽B三":"iem","葉B":"iep",
  "添四":"im","怗":"ip",
  "覃一":"am","合":"ap",
  "歌一":"aa",
  "戈一合":"wa","戈三":"ia","戈三合":"ua",
  "麻二":"a","麻二合":"wa","麻三":"ia",
  "支A三":"i","支A三合":"wi",
  "支B三":"i","支B三合":"wi",
  "脂A三":"i","脂A三合":"wi",
  "脂B三":"i","脂B三合":"wi",
  "之三":"i",
  "微三":"ei","微三合":"wei",
  "魚三":"iu",
  "模一":"uu",
  "虞三合":"u",
  "泰一":"ai","泰一合":"wai",
  "廢三":"iay","廢三合":"yay",
  "夬二":"ai","夬二合":"wai",
  "佳二":"ay","佳二合":"way",
  "皆二":"aay","皆二合":"waay",
  "祭A三":"ie","祭A三合":"ue",
  "祭B三":"ie","祭B三合":"ue",
  "齊四":"ey","齊四合":"wey",
  "咍一":"aay","灰一合":"waay",
  "豪一":"au",
  "肴二":"iau",
  "宵A三":"ieu",
  "宵B三":"iew",
  "蕭四":"iao",
  "尤三":"iou",
  "侯一":"ow",
  "幽三":"iu",
};

const RU_RIME_MAP = {
  "東":"屋","冬":"沃","鍾":"燭","江":"覺","唐":"鐸","陽":"藥",
  "庚":"陌","耕":"麥","清":"昔","青":"錫","登":"德","蒸":"職",
  "眞A":"質A","眞B":"質B","臻":"櫛","諄":"術","魂":"沒","欣":"迄","文":"物",
  "寒":"曷","桓":"末","元":"月","刪":"黠","山":"鎋",
  "仙A":"薛A","仙B":"薛B","先":"屑",
  "侵A":"緝A","侵B":"緝B","談":"盍","嚴":"業","凡":"乏","銜":"狎","咸":"洽","鹽A":"葉A","鹽B":"葉B","添":"怗","覃":"合",
};

function makeRimeKey(rimeName, deng, kaihe, tone){
  let base = rimeName;
  if (tone === "入") base = RU_RIME_MAP[rimeName] || rimeName;
  if (base === "寒" && deng === "一" && kaihe === "開" && tone !== "入") return "寒一開";
  const key = base + deng + (kaihe === "合" ? "合" : "");
  if (MASTER_RIME_ROMAN[key]) return key;
  if (MASTER_RIME_ROMAN[base]) return base;
  const key2 = base + deng;
  if (MASTER_RIME_ROMAN[key2]) return key2;
  return key;
}

function initialGroup(mu){
  const dorsal = new Set(["見","溪","群","疑"]);
  const retroflex = new Set(["知","徹","澄","娘"]);
  const dental = new Set(["精","清","從","心","邪","照","穿","牀","莊","初","崇","章","昌","常","審","禅","生","俟","書","船"]);
  if (dorsal.has(mu)) return "dorsal";
  if (retroflex.has(mu)) return "coronal";
  if (dental.has(mu)) return "coronal";
  const labial = new Set(["幫","滂","並","明","非","敷","奉","微"]);
  if (labial.has(mu)) return "labial";
  return "other";
}

function extractNucleus(r){
  if (r === "iu" || r === "uu") return { nucleus: r[0], start: 0, len: 1 };
  const vowels = new Set(["a","e","i","o","u","y"]);
  let i = 0;
  while (i < r.length && ["i","u","w","y"].includes(r[i])) {
    const nxt = r[i+1];
    if (nxt && vowels.has(nxt)) { i++; continue; }
    break;
  }
  if (i >= r.length) return { nucleus: r[0] || "", start: 0, len: 1 };
  if (r.slice(i,i+2) === "aa") return { nucleus:"aa", start:i, len:2 };
  return { nucleus:r[i], start:i, len:1 };
}

function hasPalatalGlide(r){
  const nuc = extractNucleus(r);
  return (r.startsWith("i") || r.startsWith("y")) && nuc.start > 0;
}
function dropLeadingPalatalGlide(r){
  if (r.startsWith("i") || r.startsWith("y")) return r.slice(1);
  return r;
}
function isOpenSyllable(r){ return /[aeiouy]$/.test(r); }
function applyBTypeCodaMutation(r, group){
  const ends = suf => r.endsWith(suf);
  if (group === "dorsal"){
    if (ends("ng")) return r.slice(0,-2) + "nh";
    if (ends("k"))  return r.slice(0,-1) + "ch";
    if (isOpenSyllable(r)) return r + "h";
    return r;
  }
  if (group === "coronal"){
    if (ends("n")) return r.slice(0,-1) + "nn";
    if (ends("t")) return r.slice(0,-1) + "ts";
    if (isOpenSyllable(r)) return r + "h";
    return r;
  }
  if (group === "labial"){
    if (ends("m")) return r.slice(0,-1) + "mh";
    if (ends("p")) return r.slice(0,-1) + "v";
    if (isOpenSyllable(r)) return r + "h";
    return r;
  }
  return r;
}

function yinToYang(n){
  if (n==="aa") return "ae";
  if (n==="a") return "ae";
  if (n==="e") return "eo";
  if (n==="i") return "y";
  if (n==="o") return "oe";
  if (n==="u") return "ue";
  return n;
}
function replaceAt(str, start, len, repl){
  return str.slice(0,start)+repl+str.slice(start+len);
}
const COMB_ACUTE="\u0301", COMB_GRAVE="\u0300";
function addToneMarkToNucleus(syl, nucleusStart, tone){
  if (tone!=="上" && tone!=="去") return syl;
  const mark = (tone==="上") ? COMB_ACUTE : COMB_GRAVE;
  const ch = syl[nucleusStart];
  return (syl.slice(0,nucleusStart)+ch+mark+syl.slice(nucleusStart+1)).normalize("NFC");
}

function postProcess(initialRoman, rimeRoman){
  const nuc = extractNucleus(rimeRoman);
  const hasIGlide = rimeRoman.startsWith("i") && nuc.start > 0;
  const hasYGlide = rimeRoman.startsWith("y") && nuc.start > 0;

  if (!initialRoman && hasIGlide) rimeRoman = "y" + rimeRoman.slice(1);
  if (["j","zh","ch","sh","x"].includes(initialRoman) && hasIGlide) rimeRoman = rimeRoman.slice(1);

  if (["b","p","m"].includes(initialRoman)) {
    if (rimeRoman.startsWith("w")) rimeRoman = rimeRoman.slice(1);
    if (hasYGlide) rimeRoman = rimeRoman.slice(1);
  }

  if ((initialRoman === "w" || initialRoman === "f") && hasYGlide) {
    rimeRoman = rimeRoman.slice(1);
  }

  // delete leading y- after initial x (always when rime starts with y)
  if (initialRoman === "x" && rimeRoman.startsWith("y")) {
    rimeRoman = rimeRoman.slice(1);
  }

  // delete glide u- after initial w (only when u is glide, not nucleus)
  if (initialRoman === "w" && rimeRoman.startsWith("u")) {
    const nucU = extractNucleus(rimeRoman);
    const hasUGlide = nucU.start > 0;
    if (hasUGlide) rimeRoman = rimeRoman.slice(1);
  }

  // delete glide i- after initial y (only when i is glide, not nucleus)
  if (initialRoman === "y" && rimeRoman.startsWith("i")) {
    const nucI = extractNucleus(rimeRoman);
    const hasIGlide2 = nucI.start > 0;
    if (hasIGlide2) rimeRoman = rimeRoman.slice(1);
  }

  if (initialRoman === "l" && rimeRoman.startsWith("w")) {
    const tmp = rimeRoman.slice(1);
    const nuc2 = extractNucleus(tmp).nucleus;
    if (["a","aa","o","u","oe","ue"].includes(nuc2)) rimeRoman = tmp;
  }

  return rimeRoman;
}

function convertOne(mc){
  const mu = (mc.initialMu || "").trim();
  const tone = (mc.tone || "").trim();
  const rimeKey = (mc.rimeKey || "").trim();

  let initialRoman = (INITIAL_ROMAN[mu]!==undefined)? INITIAL_ROMAN[mu] : "";
  let shiftedLabial = false;

  if ((mc.kaihe || "").trim() === "合") {
    if (mu === "幫" || mu === "滂" || mu === "並") { initialRoman = "f"; shiftedLabial = true; }
    if (mu === "明") { initialRoman = "w"; shiftedLabial = true; }
  }

  let rimeRoman = RIME_ROMAN[rimeKey];
  if (typeof rimeRoman !== "string" || rimeRoman.length === 0) return { ok:false, error:`韻キー未対応：${rimeKey}` };

  if (shiftedLabial && rimeRoman.startsWith("w")) rimeRoman = rimeRoman.slice(1);

  const grp = initialGroup(mu);
  let isB = false;

  if ((grp==="dorsal" || grp==="coronal") && hasPalatalGlide(rimeRoman)) {
    isB = true;
    rimeRoman = dropLeadingPalatalGlide(rimeRoman);
    rimeRoman = applyBTypeCodaMutation(rimeRoman, grp);
  }

  rimeRoman = postProcess(initialRoman, rimeRoman);

  const voiced = VOICED_MU.has(mu);
  if (voiced){
    const nuc3 = extractNucleus(rimeRoman);
    rimeRoman = replaceAt(rimeRoman, nuc3.start, nuc3.len, yinToYang(nuc3.nucleus));
  }

  const nuc2 = extractNucleus(rimeRoman);
  const base = initialRoman + rimeRoman;
  const nucleusStart = initialRoman.length + nuc2.start;
  const withTone = addToneMarkToNucleus(base, nucleusStart, tone);

  return { ok:true, reading: withTone, debug:{ initialRoman, rimeRoman, voiced, isB, grp } };
}

function loadFromText(text){
  const lines = text.split(/\r?\n/);
  const idx = new Map();
  const rimeNameSet = new Set();
  const keySet = new Set();
  const missing = new Set();

  for (const line of lines){
    const p = parseLine(line);
    if (!p) continue;
    const chars = splitIdeographs(p.charsRaw);
    if (chars.length === 0) continue;

    rimeNameSet.add(p.rimeName);

    const xiaoyun = `${p.fanqie}${chars[0] ? "（"+chars[0]+"）" : ""}`;
    const rimeKey = makeRimeKey(p.rimeName, p.deng, p.kaihe, p.tone);
    keySet.add(rimeKey);

    const mc = { initialMu: p.initialMu, kaihe:p.kaihe, deng:p.deng, rimeName:p.rimeName, tone:p.tone, rimeKey };

    for (const ch of chars){
      const entry = { char: ch, xiaoyun, mc };
      if (!idx.has(ch)) idx.set(ch, []);
      idx.get(ch).push(entry);
    }
  }

  const r = {};
  for (const k of keySet){
    if (MASTER_RIME_ROMAN[k]) r[k] = MASTER_RIME_ROMAN[k];
    else missing.add(k);
  }
  RIME_ROMAN = r;
  INDEX = idx;

  document.getElementById("rimeNames").value = Array.from(rimeNameSet).sort().join("\n");
  document.getElementById("missingKeys").value = Array.from(missing).sort().join("\n");

  setStatus(`読み込み完了：索引文字数=${INDEX.size} / 未対応キー=${missing.size}`, missing.size ? "warn" : "ok");
}

function render(){
  const out = document.getElementById("out");
  out.innerHTML = "";
  if (!INDEX || INDEX.size === 0){
    out.innerHTML = `<div class="status warn">DBが未読み込みです。</div>`;
    return;
  }
  const input = document.getElementById("q").value.trim();
  if (!input) return;

  const chars = Array.from(input).filter(isCjkIdeograph);
  if (chars.length === 0) return;

  for (const ch of chars){
    const hits = INDEX.get(ch) || [];
    const block = document.createElement("div");
    block.className = "charBlock";

    const title = document.createElement("div");
    title.className = "charTitle";
    title.innerHTML = `<div class="han">${escapeHtml(ch)}</div><div class="meta">一致件数：${hits.length}</div>`;
    block.appendChild(title);

    if (!hits.length){
      const w = document.createElement("div");
      w.className = "status warn";
      w.textContent = "該当なし";
      block.appendChild(w);
      out.appendChild(block);
      continue;
    }

    hits.forEach((e, i) => {
      const conv = convertOne(e.mc);
      const div = document.createElement("div");
      div.className = "entry";
      div.innerHTML = `
        <div class="entryHeader">
          <span class="tag">#${i+1}</span>
          <span class="tag">小韻：${escapeHtml(e.xiaoyun)}</span>
          <span class="tag">中古：${escapeHtml(e.mc.initialMu)} + ${escapeHtml(e.mc.rimeKey)}（${escapeHtml(e.mc.tone)}）</span>
        </div>
        <div class="reading mono">${escapeHtml(conv.ok ? conv.reading : "（変換エラー）")}</div>
        <div class="small mono">${escapeHtml(conv.ok ? `init=${conv.debug.initialRoman||"∅"} / rime=${conv.debug.rimeRoman} / 乙類=${conv.debug.isB}` : conv.error)}</div>
      `;
      block.appendChild(div);
    });

    out.appendChild(block);
  }
}

function bindTap(el, fn){
  // Robust tap handler for mobile/webviews. Prevents double-trigger.
  let locked = false;
  const run = async (e) => {
    if (locked) return;
    locked = true;
    try { await fn(e); } finally { setTimeout(()=>{ locked=false; }, 350); }
  };
  el.addEventListener("click", run);
  el.addEventListener("pointerup", run);
  el.addEventListener("touchend", (e)=>{ e.preventDefault(); run(e); }, { passive:false });
}

async function loadKuankhiunnFromInputUrl(){
  const url0 = document.getElementById("url").value.trim();
  if (!url0) return setStatus("URLが空です。", "bad");

  const url = normalizeTextUrl(url0);

  try{
    setStatus(`取得中… ${url}`, "warn");
    const res = await fetch(url, { cache:"no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
    const text = await res.text();
    loadFromText(text);
    render();
  }catch(e){
    setStatus(`取得失敗：${String(e)}`, "bad");
  }
}

// ---- bindings ----
const loadBtn = document.getElementById("loadUrlBtn");
bindTap(loadBtn, loadKuankhiunnFromInputUrl);

document.getElementById("searchBtn").addEventListener("click", render);
document.getElementById("q").addEventListener("keydown", e=>{ if (e.key==="Enter") render(); });
document.getElementById("demoBtn").addEventListener("click", ()=>{
  document.getElementById("q").value = "四申請網";
  render();
});

// Auto-load on open (GitHub Pagesで ./Kuankhiunn0704.txt を読む想定)
window.addEventListener("DOMContentLoaded", () => {
  if (document.getElementById("url").value.trim()) {
    loadKuankhiunnFromInputUrl();
  }
});
</script>
</body>
</html>
